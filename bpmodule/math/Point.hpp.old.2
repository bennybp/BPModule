/* 
 * File:   TPoint.hpp
 * Original Author: Ryan Richard <ryanmrichard1@gmail.com>
 *
 * Created on January 22, 2016, 11:46 AM
 */

#ifndef BPMODULE_GUARD_POINT_HPP_
#define BPMODULE_GUARD_POINT_HPP_

#include <array>

namespace bpmodule{
namespace math{


// Templated, because why not
template<typename T>
class TPoint
{
    public:
        TPoint(T x, T y, T z)
            : xyz_{x, y, z} { }

        virtual ~TPoint() =  default;

        // All these OK
        TPoint(const TPoint &) = default;
        TPoint(TPoint &&) = default;
        TPoint & operator=(const TPoint &) = default;
        TPoint & operator=(TPoint &&) = default;

        // Comparisons
        bool operator==(const TPoint & rhs) const { return xyz_ == rhs.xyz_; }
        bool operator!=(const TPoint & rhs) const { return xyz_ != rhs.xyz_; }
        bool operator<=(const TPoint & rhs) const { return xyz_ <= rhs.xyz_; }
        bool operator<(const TPoint & rhs) const { return xyz_ < rhs.xyz_; }
        bool operator>=(const TPoint & rhs) const { return xyz_ >= rhs.xyz_; }
        bool operator>(const TPoint & rhs) const { return xyz_ > rhs.xyz_; }


        // Mathematical operations
        TPoint & operator+=(const TPoint & rhs)
        {
            xyz_[0] += rhs.xyz_[0];
            xyz_[1] += rhs.xyz_[1];
            xyz_[2] += rhs.xyz_[2];
            return *this;
        }


        TPoint operator+(const TPoint & rhs) const
        {
            TPoint tmp(*this);
            tmp += rhs;
            return tmp;
        }


        TPoint & operator-=(const TPoint & rhs)
        {
            xyz_[0] -= rhs.xyz_[0];
            xyz_[1] -= rhs.xyz_[1];
            xyz_[2] -= rhs.xyz_[2];
            return *this;
        }

        TPoint operator-(const TPoint & rhs) const
        {
            TPoint tmp(*this);
            tmp -= rhs;
            return tmp;
        }
        

        // elementwise multiplication
        TPoint & operator*=(const TPoint & rhs)
        {
            xyz_[0] *= rhs.xyz_[0];
            xyz_[1] *= rhs.xyz_[1];
            xyz_[2] *= rhs.xyz_[2];
            return *this;
        }

        TPoint operator*(const TPoint & rhs) const
        {
            TPoint tmp(*this);
            tmp *= rhs;
            return tmp;
        }


        // scalar multiplication
        TPoint & operator*=(const T & a) const
        {
            xyz_[0] *= a;
            xyz_[1] *= a;
            xyz_[2] *= a;
            return *this;
        }

        TPoint operator*(const T & a) const
        {
            TPoint tmp(*this);
            tmp *= rhs;
            return tmp;
        }


        T & operator[](int i) noexcept { return xyz_[i]; }
        const T & operator[](int i) const noexcept { return xyz_[i]; }

    private:
        std::array<T, 3> xyz_;
};


// scalar multiplication (scalar on left)
template<typename T>
TPoint<T> operator*(const T & a, const TPoint<T> & p)
{
    return p*a;
}



// typedefs
typedef TPoint<double> Point;



}
}//End namespaces

#endif /* BPMODULE_GUARD_POINT_HPP_ */


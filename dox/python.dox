/////////////////////////
// Developer page      //
// Python stuff        //
/////////////////////////
/*! \page developer_python_page Python

\section python_smart_pointer Smart Pointers in Python

When code tries to obtain an attribute from a python object,
and the attribute does not exist for that object, python will
then look for a \c \_\_getattr\_\_ attribute instead, passing to it
the name of the attribute it wants.

\code{.py}
#!/usr/bin/env python3

class MyClass:
  def Func(self, s):
    print(s)

m = MyClass()
m.Func("Hello")          # Calls MyClass.Func(s)
m.SomethingElse("Hello") # Calls MyClass.__getattr__("SomethingElse")(s)
\endcode

This behavior can be used to implement something conceptually similar
to a C++ smart pointer in python.


\code{.py}
class MyClass:
  def __init__(self, obj):
    self.obj = obj
  
  def Func(self, s):
    print(s)

  def __getattr__(self, name):
    return getattr(self.obj, name)
  

class MyObj:
  def SomethingElse(self, s):
    print("In MyObj: {}".format(s))
  

o = MyObj()
m = MyClass(o)

m.Func("Hello")          # Calls MyClass.Func(s)
m.SomethingElse("Hello") # Calls MyClass.__getattr__("SomethingElse")(s)
                         #   = MyClass.obj.SomethingElse(s)
\endcode

This can be exploited easily by C++ classes that behave like smart
pointers that are exported to python. All that is needed is a
member function that is exported to python that is given the name \c \_\_getattr\_\_, and this function will be called if a given attribute
cannot be found when an object of the class is used from python.

\code{.cpp}

class SomeClass
{
    public:

    pybind11::object Py__getattr__(const std::string & name)
    {
        return obj_.attr(name.c_str());
    }
};


PYBIND11_PLUGIN(myplugin)
{
    pybind11::module m("myplugin", "My plugin description");

    pybind11::class_<SomeClass>(m, "SomeClass")
    .def("__getattr__", &PyModulePtr::Py__getattr__)
    ;
}

\endcode

*/


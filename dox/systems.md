How to Make and Use Systems                                          {#systems}
===========================

In Pulsar we term the entire system of interest, the molecule, its atoms, its
basis functions, any fields it is embedded in, etc. the *system*.
Consequentially, the System class is your main source of information about the
chemistry the user is trying to model.  This page walks you through the parts
of the Pulsar System class and also covers basic system manipulations.

## The Atom Class

Arguably the lowest level part of the system is the atoms.  In Pulsar each
atom is responsible for holding information pertaining to the nucleus and the
electrons.  The majority of the class is autopopulated for you if you use one of
the factory functions provided.  These are functions like:
~~~{.cpp}
//Makes a hydrogen atom at the origin
Atom H=pulsar::system::create_atom({0.0,0.0,0.0},1);

//Makes a deuterium atom at the origin
Atom D=pulsar::system::create_atom({0.0,0.0,0.0},1,2);
~~~

They are mirrored in Python:
~~~{.py}
#Makes a hydrogen atom at the origin
H=psr.system.create_atom([0.0,0.0,0.0],1)

#Makes a deuterium atom at the origin
D=psr.system.create_atom([0.0,0.0,0.0],1,2)
~~~

When you use these functions the mass, charge, multiplicity, number of elctrons,
etc. are auto filled in for you.  You are free to change any of the values,
after instantiation if the values do not suite your needs.

Pulsar has support for several types of pseudoatoms.  Likely one of the more
common pseudoatoms is the *ghost* atom, which has all the basis functions of a
particular atom, but no nucleus or electrons.  *point charges* are as the name
implies, nothing more than a charge at a point in space; no basis functions, no
electrons, no nucelus.  And *dummy* atoms are just points; no basis functions,
no charge, no electrons, no nuclues.  Ghost atoms usually appear when using
supermolecular methods to compute energy differences to correct for the
so-called basis set superposition error.  Point charges are used to simulate
classical electrostatic fields such as those generated by a solvent.  Dummy
atoms are usually used to specify a specific location in space either for
property analysis (e.g. I want the electrostatic potential at this point) or
for simplifying input of molecules using Z-matrix format.

Like actual atoms, each pseduo atom has a factory function associated with it.
Such as:
~~~{.cpp}
//Make an atom
Atom AnAtom=pulsar::system::create_atom({0.0,1.0,0.0},6);

//"Ghost" it
Atom GH=pulsar::system::make_ghost_atom(AnAtom);

//Put a charge at its location
Atom q=pulsar::system::make_point_charge(AnAtom,Charge);

//or...
Atom q2=pulsar::system::make_point_charge({0.0,1.0,0.0},Charge);

//Put a dummy atom at its location
Atom Dm=pulsar::system::make_dummy_atom(AnAtom);

//or...
Atom Dm2=pulsar::system::make_dummy_atom({0.0,1.0,0.0});
~~~

Again, mirrord Python bindings are available:

~~~{.py}
#Make an atom
AnAtom=psr.system.create_atom([0.0,1.0,0.0],6)

#"Ghost" it
GH=psr.system.make_ghost_atom(AnAtom)

#Put a charge at its location
q=psr.system.make_point_charge(AnAtom,Charge)

#or...
q2=psr.system.make_point_charge([0.0,1.0,0.0],Charge)

#Put a dummy atom at its location
Dm=psr.system.make_dummy_atom(AnAtom)

#or...
Dm2=psr.system.make_dummy_atom([0.0,1.0,0.0])
~~~

In order to hide the user from the details of how Pulsar determines when an atom
is a dummy atom versus when it is a ghost atom.  We have made functions that
will do this for you.  You are encouraged to use them in case the conditions
ever change.  They are:

~~~{.cpp}
//True if AnAtom is a ghost atom
bool IsGhost=pulsar::system::is_ghost_atom(AnAtom);

//True if AnAtom is a point charge
bool IsCharge=pulsar::system::is_point_charge(AnAtom);

//True if AnAtom is a dummy atom
bool IsDummy=pulsar::system::is_dummy_atom(AnAtom);
~~~

and yet again these are mirrored in Python:

~~~{.py}
#True if AnAtom is a ghost atom
IsGhost=psr.system.is_ghost_atom(AnAtom)

#True if AnAtom is a point charge
IsCharge=psr.system.is_point_charge(AnAtom)

#True if AnAtom is a dummy atom
IsDummy=psr.system.is_dummy_atom(AnAtom)
~~~

I suspect in most cases you will not want to deal the pseduoatoms, for example
in an energy method you'll only want the real atoms contained in a system or
you'll just want the basis set regardless of whether the basis functions came
from an actual atom or a ghost atom.  Rather than having to manually check each
atom we have provided functions for these tasks, which are described in the
section on how to use the System class.

## Space Class

The System class is made of two components a set of Atom instances and an
instance of the Space class.  By default space is a cold and lonely place that
contains nothing aside from your atoms, to infinty in each direction.  This is
what we want for most typical electronic structure computations.  However, with
much focus shifting to condensed phases this is no longer a given.  To allow
for the specification of things beyond our set of atoms we have created the
Space class.  At the moment the only thing it includes are periodic boundary
conditions and lattice parameters (i.e. the shape of the periodic boundary 
conditions).  In the future this will be the home of higher-order 
electrostatic fields (i.e. not point charges), thermostats, non-atom centered
basis sets (plane waves, dirac delta functions, etc.), and magnetic fields.
Basically we anticipate this being the grab bag of things that are relevant for 
specifying the input of your problem aside from just what atoms are there.

Right now you can do the following:
~~~{.cpp}
#include "pulsar/constants.h"//For PI
Space MySpace;//Not endoresed by the antiquated website...

bool IsPeriodic=MySpace.is_periodic();//By default no, but

Space MyUnitCell({1.0,1.0,1.0},{PI/2,PI/2,PI/2});//A cubic cell that is 1 bohr^3

bool IsPeriodic2=MyUnitCell.is_periodic();//Now it's true

//sides will be [infnity,infinity,infinty] (double value of infinity)
std::array<double,3> sides=MySpace.lattice_sides;

//sides will be [1.0,1.0,1.0]
sides=MyUnitCell.lattice_sides;

//Angles are [1.57,1.57,1.57]
std::array<double,3> angles=MySpace.lattice_angles;//I decided infinite space is cubic

//Angles are still [1.57,1.57,1.57]
angles=MyUnitCell.lattice_angles;
~~~

You guessed it, this is mirrored in Python:

~~~{.py}
import math

MySpace=Space()#Not endoresed by the antiquated website...

IsPeriodic=MySpace.is_periodic()#By default no

MyUnitCell=Space([1.0,1.0,1.0],[PI/2,PI/2,PI/2])#A cubic cell that is 1 bohr^3

IsPeriodic2=MyUnitCell.is_periodic()#This is true

#sides will be [infnity,infinity,infinty] (double value of infinity)
sides=MySpace.lattice_sides

#sides will be [1.0,1.0,1.0]
sides=MyUnitCell.lattice_sides

#Angles are [1.57,1.57,1.57]
angles=MySpace.lattice_angles#I decided infinite space is cubic

#Angles are still [1.57,1.57,1.57]
angles=MyUnitCell.lattice_angles
~~~

\todo Export Pulsar constants to Python

## System Class

Now that we understand the two main components of the System class we are ready
to discuss the actual System Class.  We suspect that vast majority of Pulsar
users and developers will simply be using it as a vessel for obtaining the basis
set and/or the information related to the fields.  Importantly they will not
care how the instance was made nor will they be making a new instance.

In this case the System class performs just like you would expect.
~~~{.cpp}
System MySystem;//Some system that has already been filled elsewhere
Atom MyAtom;//Some Atom that is already created elsewhere

//Get the number of atoms
size_t NAtoms=MySystem.size();

//Get the mass
double Mass=MySystem.mass;

//Get the number of electrons
double NElec=MySystem.nelectrons;

//Get the multiplicity
double Multiplicity=MySystem.multiplicity;

//Get the Space
Space MySpace=MySystem.space;

//See if our System contains an atom
bool HasAtom=MySystem.count(MyAtom);

//Add an atom to it
MySystem.insert(MyAtom);

//Loop over all the atoms in it [you can also use *.begin() and *.end()]
for(const Atom& ai: MySystem)
   /* Do something with the i-th atom */

//Check if two systems are equal
bool AreEqual= MySystem==SomeOtherSystem;

//Get the BasisSet of this system
BasisSet BS=MySystem.get_basis_set();
~~~

It's worth noting that if you have a non-const version of a System you can
directly modify the mass, multiplicity, etc. as they are public member variables.
The set of atoms, however, is not publicly accessible because behind the 
scenes the System class needs to do some bookkeeping to make sure the mass, 
charge, etc. are always correct for the system as it stands (consequentially if 
you manually set the charge, mass, etc. then adding another atom will change it,
so always manually set those member variables last).

\note The information for the basis set is stored in each Atom class.  The
get_basis_set() function collects it all into a class (including
basis functions from ghost atoms) more in line with what typical users are used
to experiencing.  For more information on the BasisSet class see 
[Making and Using Basis Sets in Pulsar](@ref basisset).

### Advanced Usage of the System Class

Aside from simply providing the details of the system, the System class was
designed for performance and manipulations involving combining many instances
in various manners (usually by union or intersection).  Internally, this is
accomplished by storing the atoms in a MathSet.  At first it may seem like
overkill for an object that is as simple as a System, but consider that each 
Atom instance contains two integers, and seven doubles, i.e. 72 bytes (assuming 
the integers are 64-bit and ignoring the std::map of basis functions).  Now 
assume that we are looking at a small protein that has say 500 atoms.  This
means one system is 35 kB.  Not a lot, but now assume we fragmented it by amino
acid (which are on average 20 atoms each), that's 25 fragments, 300 dimers, and 
2,300 trimers.  If each one of those contained all of the atoms in the full 
protein, in some form (point charges, ghost atoms, etc.) that would be 89.3 MB. 
That's a small protein with no solvent/ligand and neglecting the basis functions
on each atom (which are comprised of many doubles themselves).  Using the 
MathSet class to hold our atoms the same info can be held with 500 64-bit 
integers, so 9.9 MB total for the 2,625 systems.  As you can see we get an order
of magnitude reduction in our memory footprint (and inclusion of the basis
functions will not increase that cost) allowing us to consider very large 
systems with ease.

Now that we have hopefully somewhat justified the slightly increase complexity
associated with the System class, let's consider the gotcha it in turn entails.
Namely, we need to be careful when building and combining System classes
because the MathSet instances must all have the same Universe.  This is simple
to account for by making a Universe that contains the union of of all atoms you 
may possibly need.  Notably this includes ghost atoms, 
point charges, and dummy atoms, in addition to the usual atoms.  The System is
fine with the Universe having both real and say ghost atoms at the same location
in space.  With such a Universe in hand the rest functions exactly as you would
expect.  To illustrate this consider setting up a counterpoise correction for
the water dimer.
~~~{.cpp}
//Assume the atoms were set up already
std::array<Atom,6> Atoms({H11,H21,O1,H12,H22,O2});

//Fill the universe with all 6 atoms and their ghost variants
AtomSetUniverse AllAtoms;
for(const Atom& ai: Atoms){
    AllAtoms.insert(ai);
    AllAtoms.insert(make_ghost(ai));
}

//Make the three empty systems
System Dimer(AllAtoms,false),Water1(Dimer),Water2(Dimer);

//Fill them
for(size_t i=0;i<Atoms.size();++i){
    const Atom& ai=Atoms[i];
    Dimer.insert(ai);
    Water1.insert(i<3?ai:make_ghost(ai));
    Water2.insert(i>3?ai:make_ghost(ai));
}
~~~
For more complicated situations the set operations greatly facilitate 
generalizations of this procedure by avoiding the if/then logic.
